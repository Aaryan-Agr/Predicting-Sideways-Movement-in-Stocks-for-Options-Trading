# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kuQ2i-kpNTL-SFetM0a-vp5hIeRWykRM
"""

import pandas as pd
import yfinance as yf
!pip install ta
import ta
import datetime
from datetime import date, timedelta
today = date.today()

# Fetching SP500 companies
url = "https://en.wikipedia.org/wiki/List_of_S%26P_500_companies"
df = pd.read_html(url)[0]
tickers = df["Symbol"].astype(str).str.strip()

df = df.astype({"Symbol": "string",
                "Security": "string",
                "GICS Sector": "string",
                "GICS Sub-Industry": "string",
                "Headquarters Location": "string"})

df["Date added"] = pd.to_datetime(df["Date added"], errors="coerce")  # Convert to datetime
df["CIK"] = pd.to_numeric(df["CIK"], errors="coerce")  # Ensure numeric
df["Founded"] = pd.to_numeric(df["Founded"], errors="coerce")  # Convert founded year to numeric

def get_stock_data(ticker):
    print("start")
    try:
        print(f"Fetching data for {ticker}...")  # Debugging print
        stock = yf.download(ticker, period="6mo", interval="1d")  # Last 6 months
        if stock.empty:
            print(f"Skipping {ticker}: No data found")
            return None

        # Ensure "Close" column is a 1D series
        close_series = stock["Close"].squeeze()  # .squeeze() converts the column to a 1D Series

        # Calculate the 60-period Moving Average
        stock["MA_60"] = close_series.rolling(window=60).mean()

        # Bollinger Bands (20,2)
        stock["BB_High"] = ta.volatility.bollinger_hband(close_series)
        stock["BB_Mid"] = ta.volatility.bollinger_mavg(close_series)
        stock["BB_Low"] = ta.volatility.bollinger_lband(close_series)

        # RSI (14)
        stock["RSI_14"] = ta.momentum.RSIIndicator(close_series, window=14).rsi()

        # MACD (12,26,9)
        macd = ta.trend.MACD(close_series, window_slow=26, window_fast=12, window_sign=9)
        stock["MACD_Line"] = macd.macd()
        stock["MACD_Signal"] = macd.macd_signal()
        stock["MACD_Hist"] = macd.macd_diff()

        # Fetch the latest stock price (close price)
        price = stock["Close"].iloc[-1]  # Get the most recent closing price

        # Return the latest values along with the ticker and price
        latest = stock.iloc[-1][["MA_60", "BB_High", "BB_Mid", "BB_Low", "RSI_14", "MACD_Line", "MACD_Signal", "MACD_Hist"]].squeeze()
        latest["Ticker"] = ticker  # Add the ticker symbol to the result
        latest["Price"] = price  # Add the latest price to the result

        return latest

    except Exception as e:
        print(f"Error fetching data for {ticker}: {e}")
        return None

j = get_stock_data('AAPL')
print(j) # Check the attributes to see if they are correct

df.head()

data_list = []
for ticker in tickers:  # Ensure we're selecting correct tickers
    print("Ola")
    stock_data = get_stock_data(ticker)
    print(stock_data)
    if stock_data is not None:
        stock_data["Ticker"] = ticker
        data_list.append(stock_data)
print("Ola")
# Create DataFrame
if data_list:
    df_stocks = pd.DataFrame(data_list).set_index("Ticker")
    print(df_stocks)
else:
    print("No valid stock data retrieved.")

import html

# Clean the column headers of df_stocks
df_stocks.columns = [html.unescape(col) for col in df_stocks.columns]

# Now you can print the cleaned-up DataFrame
# Convert columns from tuple format to simple strings
df_stocks.columns = [col[0] for col in df_stocks.columns]

# Print the cleaned DataFrame
print(df_stocks.columns)

df_stocks.head(34)

df.head()

dfdata = pd.merge(df, df_stocks, left_on='Symbol', right_on='Ticker', how='outer')

import yfinance as yf

def fetch_latest_price(symbol):
    # Convert dot-format tickers to Yahoo Finance's dash format
    yahoo_ticker = symbol.replace('.', '-')

    try:
        stock = yf.Ticker(yahoo_ticker)
        price = stock.history(period="1d")['Close'].iloc[-1]  # Get last closing price
        return price
    except Exception as e:
        print(f"Error fetching price for {symbol} ({yahoo_ticker}): {e}")
        return None

# Apply function to fill missing prices
dfdata['Price'] = dfdata['Symbol'].apply(fetch_latest_price)

# Check if we still have NaNs
print(dfdata[['Price']].isnull().sum())

"""Now we have the data set we can take a deep dive into analysis of the stocks by filtering with industry"""

dfdata.info()

print(dfdata.dtypes)
print(dfdata[['Price']].head(10))  # Show first 10 values in Price column

# Convert 'Price' to numeric, forcing errors to NaN (this will drop non-numeric values)
dfdata['Price'] = pd.to_numeric(dfdata['Price'], errors='coerce')

# Check for missing values in the relevant columns
print(dfdata[['MA_60', 'MACD_Signal', 'Price']].isnull().sum())

# Remove rows with NaN values in key columns
dfdata_cleaned = dfdata.dropna(subset=['MA_60', 'MACD_Signal', 'Price']).copy()  # Use .copy() to avoid SettingWithCopyWarning

# Ensure the 'Price' column has valid values
dfdata_cleaned['Price'] = dfdata_cleaned['Price'].replace(0, 1)  # Avoid division by zero

# Calculate Normalized Difference
dfdata_cleaned.loc[:, 'Normalized_Diff'] = (dfdata_cleaned['MA_60'] - dfdata_cleaned['MACD_Signal']) / dfdata_cleaned['Price']

# Group by GICS Sector and Sub-Industry, calculate thresholds
threshold_df = dfdata_cleaned.groupby(['GICS Sector', 'GICS Sub-Industry'])['Normalized_Diff'].agg(['mean', 'std'])

# Calculate Upper and Lower Thresholds
threshold_df['Upper Threshold'] = threshold_df['mean'] + threshold_df['std']
threshold_df['Lower Threshold'] = threshold_df['mean'] - threshold_df['std']

# Display the threshold DataFrame
#print(threshold_df)

# Group by GICS Sector only, calculating mean, std, and other statistics for Normalized_Diff
sector_threshold_df = dfdata_cleaned.groupby('GICS Sector')['Normalized_Diff'].agg(['mean', 'std'])

# Calculate Upper and Lower Thresholds for each GICS Sector
sector_threshold_df['Upper Threshold'] = sector_threshold_df['mean'] + sector_threshold_df['std']
sector_threshold_df['Lower Threshold'] = sector_threshold_df['mean'] - sector_threshold_df['std']

# Display the new sector-based threshold DataFrame
print(sector_threshold_df)

group_sizes = dfdata_cleaned.groupby(['GICS Sector', 'GICS Sub-Industry']).size()
print(group_sizes[group_sizes <=3])  # Groups with only one data point

threshold_df.info()
sector_threshold_df.info()

def threshold_model(row, threshold_df):
    # Get the relevant sector and sub-industry from the row
    sector = row['GICS Sector']
    sub_industry = row['GICS Sub-Industry']

    # Check if this combination exists in threshold_df
    if (sector, sub_industry) in threshold_df.index:
        sector_sub_industry_thresholds = threshold_df.loc[(sector, sub_industry)]

        # Compare the Normalized_Diff with thresholds
        if row['Normalized_Diff'] > sector_sub_industry_thresholds['Upper Threshold']:
            return 'Upward Trend'
        elif row['Normalized_Diff'] < sector_sub_industry_thresholds['Lower Threshold']:
            return 'Downward Trend'
        else:
            return 'Sideways Movement'
    else:
        return 'No Data for This Sector/Sub-Industry'

# Apply this function to your cleaned DataFrame
dfdata_cleaned['Trend Prediction'] = dfdata_cleaned.apply(threshold_model, threshold_df=threshold_df, axis=1)

# Show the predictions
print(dfdata_cleaned[['Symbol', 'Trend Prediction']])

def sector_model(row, sector_threshold_df):
    # Get the relevant sector from the row
    sector = row['GICS Sector']

    # Check if this sector exists in sector_threshold_df
    if sector in sector_threshold_df.index:
        sector_thresholds = sector_threshold_df.loc[sector]

        # Compare the Normalized_Diff with thresholds
        if row['Normalized_Diff'] > sector_thresholds['Upper Threshold']:
            return 'Upward Trend'
        elif row['Normalized_Diff'] < sector_thresholds['Lower Threshold']:
            return 'Downward Trend'
        else:
            return 'Sideways Movement'
    else:
        return 'No Data for This Sector'

# Apply this function to your cleaned DataFrame
dfdata_cleaned['Sector Trend Prediction'] = dfdata_cleaned.apply(sector_model, sector_threshold_df=sector_threshold_df, axis=1)

# Show the predictions
print(dfdata_cleaned[['Symbol', 'Sector Trend Prediction']])

dfdata_cleaned.info()

import pandas as pd
import yfinance as yf
from datetime import datetime

# Define the function to get the earnings date
def get_earnings_date(symbol):
    try:
        stock = yf.Ticker(symbol)
        earnings_dates = stock.earnings_dates  # Returns a DataFrame of earnings dates
        if not earnings_dates.empty:
            print("hello")
            latest_earnings_date = earnings_dates.index[0]
            print(latest_earnings_date)  # The most recent earnings date
            return latest_earnings_date
        else:
            return None
    except Exception as e:
        print(f"Error fetching earnings date for {symbol}: {e}")
        return None


# Example: Assume dfdata_cleaned is your existing DataFrame
# Add today's date to all rows in 'Date' column
dfdata_cleaned['Date'] = pd.to_datetime('today').normalize()  # Normalize to remove time

# Apply the get_earnings_date function to fetch earnings date for each stock symbol
dfdata_cleaned['Earnings Date'] = dfdata_cleaned['Symbol'].apply(get_earnings_date)

# Ensure both 'Date' and 'Earnings Date' are naive (remove timezone info)
dfdata_cleaned['Earnings Date'] = dfdata_cleaned['Earnings Date'].dt.tz_localize(None)

# Calculate the time to next earnings (if available)
dfdata_cleaned['Time to Next Earnings'] = (dfdata_cleaned['Earnings Date'] - dfdata_cleaned['Date']).dt.days

# Check the result
print(dfdata_cleaned[['Symbol', 'Earnings Date', 'Date', 'Time to Next Earnings']])

get_earnings_date('NVDA')
